\documentclass[12pt]{report}
\usepackage{url}
\usepackage[spanish]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{geometry}\geometry{top=5cm,bottom=2cm,left=3cm,right=3cm}
\usepackage{graphicx}
\usepackage{txfonts}
\usepackage{glossaries}
\usepackage[pdfborder={0,0,0}]{hyperref}

\begin{document}

\chapter{Introducci\'on}

\chapter{Lenguajes de dominio espec\'ifico}

\section{Introducci\'on}

Usaremos la definición de DSL provista por \cite{van2000domain}: un DSL es un lenguaje de programació lenguaje de especificación ejecutable que ofrece poder de expresión enfocado en (y generalmente restringido a) un dominio de problemas en particular, a través de notaciones y abstracciones apropiadas.

Clasificaremos los DSLs según su forma de implementación: interno (también llamado embebido) o externo.

\subsection{Caracter\'isticas}

Generalmente los DSLs son \textit{pequeños}, en el sentido de que modelan solamente los conceptos y operaciones del dominio que tratan. Muchos DSLs tienden a ser declarativos, es decir, tienden a definir reglas y estructuras sobre el dominio y luego son transformados a un programa ejecutable por un compilador, intérprete u otro tipo de transformación. \cite{van2000domain}
Otras características de los DSLs incluyen: \cite{van2000domain}

\begin{itemize}
	\item Concisos, precisos
	\item Reutilizables
	\item Encapsulan 
	\item Mantenibles \cite{van1998little}
\end{itemize}



\subsection{Implementaci\'on de DSLs}

\subsubsection{DSLs internos}

Los DSLs embebidos 

\subsubsection{DSLs externos}

\chapter{Frameworks web}

\chapter{Hacia un DSL para desarrollo web en un lenguaje funcional}

Para diseñar el DSL propuesto en este trabajo, empecemos con la metodología propuesta en \cite{van1998little}:

\begin{itemize}
	\item Identificar el dominio del problema a tratar.
	\item Recopilar todo el conocimiento relevante en dicho dominio.
	\item Resumir este conocimiento a sus nociones semánticas y operaciones fundamentales.
	\item Construir una librería que implemente estas nociones semánticas y operaciones
	\item Diseñar un DSL que describa en forma concisa las aplicaciones en este dominio.
	\item Diseñar e implementar un compilador que convierta los programas escritos en DSL a una secuencia de llamadas a la librería implementada.
\end{itemize}

Nuestro dominio a tratar será el de las ``aplicaciones web``. Esto significa que el experto del dominio, el usuario final del DSL, será un programador web. Con el objetivo de maximizar la reusabilidad del DSL, no restringiremos la clase de aplicaciones target del DSL sino sólo su arquitectura de base (web). 

Elegimos la modalidad de DSL embebido para implementar nuestro DSL por las ventajas mencionadas anteriormente. El lenguaje host será F\# por sus facilidades para programación orientada al lenguaje \cite{syme2007expert} \cite{pickering2007foundations} \cite{smith-lop} \cite{petricek-lop}.

Diseñaremos nuestro DSL sobre la infraestructura de ASP.NET MVC \cite{mvc}, esta infraestructura ya encapsula el conocimiento del dominio, sus conceptos y operaciones. 
Como mencionamos anteriormente, una aplicación web se compone de varias tecnologías disímiles débilmente acopladas. Diseñaremos nuestro DSL con el objetivo de orquestrar las operaciones a ejecutar en el servidor, delegando la generación de la vista (HTML / CSS) a otros frameworks. ASP.NET MVC permite reemplazar fácilmente el generador de vistas \cite{mvcrender}, por lo cual nuestra solución podría usarse con generadores como Web Forms, Spark \cite{spark} o Brail \cite{brail}. A los efectos de representar todos los aspectos de una aplicación en un único lenguaje, utilizaremos Wing Beats \cite{wingbeats} como generador de vistas en los ejemplos y aplicación de referencia.
También delegaremos otro componente que a veces se incluye en un framework web: el acceso a datos

\addcontentsline{toc}{section}{Referencias}
\bibliographystyle{plain}
\bibliography{tesis}

\end{document}